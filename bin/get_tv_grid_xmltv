#!/usr/bin/perl

# $Date$
# $Revision$
#
#---------------------------------------------------------------------------
#  File:
#      get_tv_grid_xmltv
#  Description:
#      See help text below
#  Author:
#      Bruce Winter    bruce@misterhouse.net   http://misterhouse.net
#  Latest version:
#      http://misterhouse.net/mh/bin
#  Change log:
#    04/25/98  Created.
#    02/--/02  Tom Witmer (mycattypes4me@myrealbox.com) adds mods
#	 11/--/07  Jim Duda changed to work with XMLTV and schedulesdirect.org
#	 11/--/07  Rick Steeves (misterhouse@corwyn.net) updated to build
#			   ia5 web pages from the XMLTV data
#   05/--/08 Some general updates to fix requiring an .ini entry
#	12/--/08 Incorporated Rick Bolen's changes for subchannels
#---------------------------------------------------------------------------

#---------------------------------------------------------------------------
#  Purpose:
#      For the days/times/channels listed, retrieve the listing data
#	   from an external XML file generated by xmltv from schedulesdirect.org and
#      store it in the listings DB.
#
#  Notes for the future:
#    - ASSUMPTION: Shows in grid do not indicate their true start or end
#      times, if they cross grid boundaries. This is somewhat avoidable
#      by choosing long durations (6 hours max), and might be partially
#      fixable by adjusting shows that seem to "repeat". (This won't work
#      for shows that are listed twice in a row, however!)
#    - Would be nice to get only primetime data for weekdays, and all
#      data for weekends. This is not yet incorporated.
#
#	Requires that a current XML files exists pulled from schedulesdirect.org
# 	using XMLTV. This file needs to be updated by running xmltv on a daily
#	basis for updates.
#	The file location should be defined in mh.private.ini as tv_xml.
#	Example:
#		tv_xml= f:/temp/tv.xml
#
#---------------------------------------------------------------------------

use strict;

#======================================================================
# Version info
#======================================================================
my ( $Pgm_Path, $Pgm_Name, $Version );

BEGIN {
    ($Version) = q$Revision$ =~ /: (\S+)/;    # Note: revision number is auto-updated by cvs
    ( $Pgm_Path, $Pgm_Name ) = $0 =~ /(.*)[\\\/](.*)\.?/;
    ($Pgm_Name) = $0 =~ /([^.]+)/, $Pgm_Path = '.' unless $Pgm_Name;
    eval "use lib '$Pgm_Path/../lib', '$Pgm_Path/../lib/site';";    # So perl2exe works
    eval "push \@INC, '$Pgm_Path/../lib/fallback';";    # So perl2exe works
}

use XMLTV::Version '$Id$ ';
use IO::File;
use Date::Manip;
Date_Init('TZ=UTC');
use POSIX 'tmpnam';
use Getopt::Long;
use XMLTV qw(best_name);
use vars '%config_parms';                                          # Not a my, as called from handy_net_utils
use Time::Local;

#======================================================================
# Variable declarations and other init
#======================================================================
# Globals
#
my ( %parms, $infile, $channel_data );
my ( @hours, @uas );
my ( $dbm_file, $dbm_file2 );
my ( %DBM, %DBM2, %DBM_channel, %DBM_html, %DBM_index );    # DBM_html is extended data for HTML
my (%showtimes);
my @weekday = qw (Sun Mon Tue Wed Thu Fri Sat);

#======================================================================
# Check invocation options, and print usage message if necessary
#======================================================================
if (
    !&GetOptions(
        \%parms,   "h",        "help",    "infile=s",      "outfile=s",     "outdir=s",
        "db=s",    "keep=s",   "skip=s",  "channel_max=s", "channel_min=s", "debug",
        "label=s", "keep_old", "purge=s", "days=s",        "day=s",         "hour=s"
    )
    or @ARGV
    or ( $parms{h} or $parms{help} )
  )
{
    print <<eof;
$Pgm_Name reads a TV grid/schedule from an XML file generated from 
(schedulesdirect.org) for it to be used by the MisterHouse program 
to create VCR and TV event reminders.

Creates a DBM for use by get_tv_info.
  Version: $Version
  Usage:
   $Pgm_Name [options]
   -h        => This help text
   -help     => This help text
   -db   xyz      => xyz is the database (tv, sat, cable, default tv)
   -name xyz      => xyz is the name of the service (TV, Dish Network,
                     Cable, etc) default is TV
   -day xyz      => xyz is the day  to get/filter.  Default is today.
   -hour xyz     => xyz is the hour to get/filter.  Default is 6pm.  Can also
                    be 'all' to get all hours.
   -days xyz     => xyz is the number of days to get/filter, starting
                    with -day.
   -channel_max xyz  => Channels above xyz will be dropped.  Default is 9999.
   -channel_min xyz  => Channels below xyz will be dropped.  Default is 1.
   -infile  xyz  => xyz is  input file, and XML file from XMLTV.
   -outfile xyz  => xyz the filtered output file.
                    Default is -outdir/day_hour.html
   -outdir  xyz  => xyz the directory the outfiles will be put in.
                    Default is mh.ini parm html_dir/{db}
   -purge  xyz  => Purge entries older than xyz days old.
   -label xyz    => Use xyz as the link lable.  Default is "VCR".
                    To disable, set to none (-label none).
   -redo         => Rebuilds the web page, even if a recent file it exits
   -timebars xyz   => Number of channels between timebars in output table.
                    Default is 5.
   -keep_old     => Do NOT delete data from the DBM that is one month older
                    than todays date
   -debug        => turn on debug info

  Example:
   $Pgm_Name -infile /media/xmtv/TV.xml

eof
    exit;
}

sub days_from_now {
    my ( $day_time, $days ) = @_;
    my $day_time2 = $day_time + $days * 60 * 60 * 24;
    my ( $day, $month, $year, $down ) = ( localtime($day_time2) )[ 3, 4, 5, 6 ];
    my $dow = (qw(Sunday Monday Tuesday Wednesday Thursday Friday Saturday))[$down];

    $month++;
    $year += 1900;
    $day = sprintf( "%02d", $day );
    return ( $dow, $down, $day, $month, $year );
}

#======================================================================
# SUB: hour_to_min
# required to figure out the column width
# the old way you knew the column witdh from parsing the HTML
#======================================================================
sub hour_to_min {
    my ($time) = @_;
    my ( $hour, $minute ) = $time =~ /(\d+):(\d+)/;
    my $minutes = $minute + $hour * 60;
    return $minutes;
}

#======================================================================
# SUB: setup
# Process invocation parameters prior to doing any real work
#======================================================================
sub setup {
    &main::read_mh_opts( \%config_parms, $Pgm_Path );

    #------------------------------------------------------------
    # Process Incoming Parameters, defaulting as necessary
    #------------------------------------------------------------
    $parms{purge}    = 2    unless $parms{purge};
    $parms{timebars} = 5    unless $parms{timebars};
    $parms{days}     = 1    unless $parms{days};
    $parms{db}       = 'tv' unless $parms{db};
    $parms{outdir}   = "$config_parms{html_dir}/$parms{db}"
      unless $parms{outdir};
    $parms{name} = 'TV' unless $parms{name};
    $parms{hour} = $config_parms{ $parms{db} . '_hours' } unless $parms{hour};

    $parms{hour} = '6pm' unless $parms{hour};
    @hours       = qw(02 06 10 14 18 22);
    %showtimes   = (
        $hours[0] => [ '02:00 AM', '02:30 AM', '03:00 AM', '03:30 AM', '04:00 AM', '04:30 AM', '05:00 AM', '05:30 AM' ],
        $hours[1] => [ '06:00 AM', '06:30 AM', '07:00 AM', '07:30 AM', '08:00 AM', '08:30 AM', '09:00 AM', '09:30 AM' ],
        $hours[2] => [ '10:00 AM', '10:30 AM', '11:00 AM', '11:30 AM', '12:00 PM', '12:30 PM', '1:00 PM',  '1:30 PM' ],
        $hours[3] => [ '2:00 PM',  '2:30 PM',  '3:00 PM',  '3:30 PM',  '4:00 PM',  '4:30 PM',  '5:00 PM',  '5:30 PM' ],
        $hours[4] => [ '6:00 PM',  '6:30 PM',  '7:00 PM',  '7:30 PM',  '8:00 PM',  '8:30 PM',  '9:00 PM',  '9:30 PM' ],
        $hours[5] => [ '10:00 PM', '10:30 PM', '11:00 PM', '11:30 PM', '00:00 AM', '00:30 AM', '01:00 AM', '01:30 AM' ],
    );

    $parms{duration} = 4 unless ( $parms{duration} );

    $parms{label}    = "VCR" unless $parms{label};      # This can also be an image link
    $parms{days}     = 1     unless $parms{days};
    $parms{redo}     = 1;
    $parms{duration} = 6     unless $parms{duration};

    # Set up DBM files
    $dbm_file  = "$config_parms{data_dir}/$parms{db}_programs.dbm";
    $dbm_file2 = "$config_parms{data_dir}/$parms{db}_channels.dbm";

    # Setting up for HTML output
    print "Tieing to $dbm_file\n";
    use Fcntl;
    use DB_File;
    tie( %DBM, 'DB_File', $dbm_file, O_RDWR | O_CREAT, 0666 )
      or print "\nError, can not open dbm file $dbm_file: $!";
    tie( %DBM2, 'DB_File', $dbm_file2, O_RDWR | O_CREAT, 0666 )
      or print "\nError, can not open dbm file $dbm_file2: $!";

}

#======================================================================
# SUB: createOutputDirs
# Create any directories/files that need creating prior to downloads
#======================================================================
sub createOutputDirs {
    mkdir $parms{outdir}, 0777 unless -d $parms{outdir};

    if ( !-d $parms{outdir} ) {
        print "FAILED TO MAKE DIR: $parms{outdir} \n";
    }
    if ( !-d $parms{outdir} . "/logos" ) {
        print "XMLTV Logos missing: $parms{outdir}/logos \n";
    }
}

#======================================================================
# SUB: processRawFile
# Takes the DBM_html array and builds the HTML pages
#======================================================================
sub processRawFile {
    createOutputDirs();
    my $day_time = time;

    #------------------------------------------------------------
    # For each number of days we're asked to retrieve...
    #------------------------------------------------------------
    for my $count ( 0 .. $parms{days} ) {

        #------------------------------------------------------------
        # Calculate the date/time of this day
        #------------------------------------------------------------
        my @day_data = days_from_now( time, $count );
        my ( $dow, $down, $day, $month, $year ) = split( ' ', "@day_data" );
        my $startDay = ${month} . "/" . ${day} . "/" . ${year};

        # Calculate the epoch time for the beginning of this day.
        # Lets us do date/time math while not having to worry so much
        # about end of day/month/year crossovers
        my $month_epoch = $month - 1;
        my $day_epoch = timelocal( 0, 0, 0, $day, $month_epoch, $year );

        #------------------------------------------------------------
        # For each hour we're supposed to retrieve...
        #------------------------------------------------------------
        for my $startHour (@hours) {
            my $hour                  = $startHour;
            my $channel_number        = '';
            my $channel_name          = '';
            my $current_time_bar      = '';
            my $rowOfLastTimeBar      = 0;
            my $rowsInCurrentOutTable = 0;

            # Convert the starting grid hour to epoch seconds
            #    from AM/PM to 24
            my $grid_start_epoch = ampm_to_hour24($hour);

            #    to seconds of the particular day
            $grid_start_epoch = &hour_to_min($grid_start_epoch) * 60;

            #    and add from midnight
            $grid_start_epoch = $grid_start_epoch + $day_epoch;

            # And calculate the end of the end of the grid in epoch seconds
            # A hack for now. Needs to caculate based of the actual end
            my $grid_end_epoch = $grid_start_epoch + 14400;

            #------------------------------------------------------------
            # Calculate the name of the output file
            #------------------------------------------------------------
            my $outfile = "$parms{outdir}/${day}_${startHour}.html";

            #------------------------------------------------------------
            # If output file already exists, and is recent enough, use
            # keep it instead of rebuilding it.
            #------------------------------------------------------------
            if (    ( -e $outfile )
                and ( 8 > -M $outfile )
                and ( 4000 < -s $outfile )
                and !$parms{redo}
                and !$parms{debug} )
            {
                print "Reusing: $outfile\n";
            }
            else {

                print "Processing array to $parms{outdir} $outfile\n"
                  if ( $parms{debug} );

                #------------------------------------------------------------
                # Open files and start the output HTML
                #------------------------------------------------------------
                open( OUT, ">$outfile" )
                  || die "Error, could not open file $outfile: $!\n";
                print OUT<<eof;
<HTML>
<HEAD>
<TITLE>$parms{name} Schedule for $dow, $month/$day/$year</TITLE>
<meta http-equiv="Expires" content="Fri, Jun 12 1981 08:20:00 GMT">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="Cache-Control" content="no-cache">
</HEAD>
<body bgcolor=gray>
eof

                #------------------------------------------------------------
                # Create date/time menu selection javascript header to page.
                # (Lets user jump to a different date/time)
                #------------------------------------------------------------
                &make_index( $hour, $down, $day, $day_time );

                # This should also really go into make_index
                ##############################################
                print OUT qq|<table border="1" BGCOLOR="#FFFFFF" CELLPADDING="2" CELLSPACING="1" WIDTH="">\n|;
                $current_time_bar =
                  qq|<tr><td colspan=2 align="center" bgcolor="#663366" width="60"><a href="/tv/$day\_$hour.html"><input border="0" width=60 height=30 type="image" name="earlier" src="/tv/logos/leftArrow.gif" value="earlier"></a></td>\n|;
                foreach my $showtime ( @{ $showtimes{$hour} } ) {
                    $current_time_bar .=
                      qq|<td bgcolor="#ffffff"><center><font face="arial, helvetica" size="2" color=""><b><nobr>$showtime</nobr></b></center></font></td>\n|;
                }

                $current_time_bar .=
                  qq|<td colspan=2 align="center" bgcolor="#663366" width="60"><a href="/tv/$day\_$hour.html"><input border="0" width=60 height=30 type="image" name="later" src="/tv/logos/rightArrow.gif" value="later"></a></td>\n|;
                $current_time_bar .= "</tr>\n";
                print OUT $current_time_bar;

                # end of what should go into make_index
                ########################################

                # Generate the listing of show times.
                # Loop through for each channel in sorted order
                foreach my $key ( sort { $a <=> $b } ( keys(%DBM_channel) ) ) {

                    # Check for every channel
                    # if past midnight adjust the date to "tomorrow"
                    my ( $channel_number, $channel_name, $channel_affiliate, $channel_image, $channel_ID ) = split( $;, $DBM_channel{$key} );
                    my $channel_number_display = $channel_number;
                    my $show_found             = 0;                 # when the beginning of the channel
                                                                    # has nothing in it, to fill in the blanks
                    my $colspan                = 0;                 # keep track of how wide a show is
                    my $colspancount           = 0;                 # track width of ttl grid
                    my $show_found             = 0;                 # has a show been found yet
                    my $max_col_span           = 8;                 # Maximum # of columns in table
                                                                    # so we can figure out when the day flips
                    my $its_late               = 0;

                    my $row_started = 0;

                    $rowsInCurrentOutTable++;

                    # Print the channel information on the left
                    print OUT
                      qq|<tr width="100%"><td bgcolor="#ffffff" align="center" colspan="2">$channel_image$channel_number_display<br>$channel_name</td>\n|;

                    # Check each defined interval to see if a show is starting
                    foreach my $showtime ( @{ $showtimes{$hour} } ) {
                        #
                        # Calculate the starting hour in epoch time
                        # Convert the showtime start to epoch seconds
                        #    from AM/PM to 24
                        my $showtime_epoch = ampm_to_hour24($showtime);

                        #    to seconds of the particular day
                        $showtime_epoch = &hour_to_min($showtime_epoch) * 60;

                        # if we're at the beginning of a day, add a day of time, because it's now tomorrow
                        if ( ( $showtime eq '00:00 AM' ) || ($its_late) ) {
                            $showtime_epoch = $showtime_epoch + 86400;
                            $its_late       = 1;
                        }
                        $showtime_epoch = $showtime_epoch + $day_epoch;

                        my ( $pgm_date, $pgm_time ) = &convert_epoch_to_time($showtime_epoch);
                        my $db_key = join( $;, $channel_number, $pgm_date, $pgm_time );

                        # If there is a value for the half hour interval
                        # figure out how long the show is and print the HTML
                        if ( $DBM_html{$db_key} ) {
                            $show_found = 1;
                            my (
                                $time_end,   $pgm_name, $pgm_title,    $pgm_air,     $time_start, $time_start_adj, $time_end_adj,
                                $pgm_rating, $pgm_desc, $pgm_date_end, $epoch_start, $epoch_end,  @pgm_category
                            ) = split( $;, $DBM_html{$db_key} );

                            # calculate how many columns the show will take up.
                            # using the difference in two times for determining grid width.
                            $colspan = int( ( $epoch_end / 60 - $epoch_start / 60 ) / 30 );

                            # If the show is longer than is left on the table,
                            #     decrease width to available space
                            if ( ( $colspancount + $colspan ) > $max_col_span ) {
                                do { $colspan = $colspan - 1; } until ( ( ( $colspancount + $colspan ) <= $max_col_span ) | $colspan < 2 );
                            }
                            $colspancount = $colspancount + $colspan;

                            # Define the program listing for display to the grid
                            print OUT &display_program(
                                $pgm_name,   $pgm_title,      $pgm_desc, $pgm_air,  $pgm_rating, $channel_number,
                                $time_start, $time_start_adj, $time_end, $pgm_date, $colspan,    @pgm_category
                            );

                        }
                        elsif ( ( !($show_found) ) & ( !($row_started) ) ) {

                            # If we didn't find a show go look in the last grid
                            # see if it's in the array searching backward for a few hours
                            my $grid_time_search = $grid_start_epoch;
                            for ( my $i = 1; $i <= 8; $i++ ) {

                                # Figure out when the last time was
                                # back up time 30 minutes
                                $grid_time_search = $grid_time_search - ( 30 * 60 );    # Backup 30 minutes
                                my ( $pgm_date_loop, $pgm_time_loop ) = &convert_epoch_to_time($grid_time_search);

                                #Build a key
                                my $search_key = join( $;, $channel_number, $pgm_date_loop, $pgm_time_loop );
                                if ( $DBM_html{$search_key} ) {

                                    # then hey we found it
                                    my (
                                        $time_end,   $pgm_name, $pgm_title,    $pgm_air,     $time_start, $time_start_adj, $time_end_adj,
                                        $pgm_rating, $pgm_desc, $pgm_date_end, $epoch_start, $epoch_end,  @pgm_category
                                    ) = split( $;, $DBM_html{$search_key} );

                                    # Show has to end before the beginning of grid or we don't really care and it's a lost cause
                                    if ( $epoch_end > $grid_start_epoch ) {

                                        # Figure out the column width
                                        $colspan = int( ( $epoch_end / 60 - $grid_start_epoch / 60 ) / 30 );

                                        # and of course display the info
                                        print OUT &display_program(
                                            $pgm_name,   $pgm_title,      $pgm_desc, $pgm_air,  $pgm_rating, $channel_number,
                                            $time_start, $time_start_adj, $time_end, $pgm_date, $colspan,    @pgm_category
                                        );
                                        $show_found   = 1;
                                        $row_started  = 1;
                                        $i            = 10;         # Kick ourselves out of the loop because we found it
                                        $colspancount = $colspan;
                                    }
                                }

                                # and if not back up another 30 minutes
                            }

                            # Otherwise just leave it blank and do the best you can
                            if ( !($show_found) ) {
                                print OUT qq|<td bgcolor="#ffffff" colspan="1" width="10%" valign="top"></td>\n|;
                                $colspancount++;
                                $row_started = 1;
                            }
                        }
                        elsif ( !($show_found) ) {
                            print OUT qq|<td bgcolor="#ffffff" colspan="1" width="10%" valign="top"></td>\n|;
                            $colspancount++;
                            $row_started = 1;
                        }

                        $row_started = 0;
                    }
                    if ( $colspancount < $max_col_span ) {    # fix for blanks at the end of the channel
                        my $colspan = $max_col_span - $colspancount;
                        print OUT qq|<td bgcolor="#ffffff" colspan="$colspan" width="$colspan| . qq|0%" valign="top"></td>\n|;
                    }

                    # print the channel information on the right
                    print OUT qq|<td bgcolor="#ffffff" align="center" colspan="2">$channel_image$channel_number_display<br>$channel_name</td>\n</tr>\n|;

                    #------------------------------------------------------------
                    # Do we need to generate a new timebar?
                    #------------------------------------------------------------
                    if ( $rowsInCurrentOutTable % $parms{timebars} == 0 ) {
                        print OUT $current_time_bar;
                    }
                }
                print OUT "</table></body></html>\n";

                close OUT;

                #------------------------------------------------------------
                # Find listing for "prime time" and make it the default index file.
                # Also, email it to someone if we have the means of doing so.
                #------------------------------------------------------------
                if (    $day == ( localtime(time) )[3]
                    and $startHour > 17
                    and $startHour <= 20 )
                {
                    use File::Copy;
                    copy( $outfile, "$parms{outdir}/index.html" );
                    print "Copied $outfile  to $parms{outdir}/index.html\n"
                      if $parms{debug};
                    if ( $parms{mail_to} ) {
                        &mail_file( $parms{mail_to}, $parms{mail_server}, $outfile, "$parms{name} Schedule for $dow, $month/$day/$year" );
                    }
                }
            }
        }
    }
}

#======================================================================
# SUB: make_index
# Create the index table, for the next 2 weeks, and for other hours in
# this day
#======================================================================
sub make_index {
    my ( $hour, $down, $day, $day_time ) = @_;
    print OUT "<center>\n<table border=1 width=100%>\n<tr>\n<td align=left>\n";    ### DW: remove bgcolors

    print OUT "<font face=arial size=+1 color=white> Listings for $parms{name} </td><td align=right>";
    print OUT "<FORM>";

    #----------------------------------------------------------------------
    # Notes to any who care: Use different window targets for different
    # results:
    #  _blank= new browser window
    #  _self = current browser window
    #  _parent = window superior to the frame
    #  _top = cancels all frames, loads in full browser window
    #  In this case, I'm using the named "output" frame, which seems to
    #  be the friendliest way to do this (in my own humble opinion.)
    #  Feel free to change this if you like.
    #----------------------------------------------------------------------
    print OUT "<SELECT NAME=url onchange=window.open(this.options[this.selectedIndex].value,'output')>\n";

    #print OUT "<SELECT NAME=url onchange=window.open(this.options[this.selectedIndex].value,'menu')>\n";
    #my $dow_start = -$down - 7;
    my $dow_start = -$parms{purge};
    my $dow_stop  = 7;

    #  my $dow_stop  = $parms{days} -1;
    for my $count ( $dow_start .. $dow_stop ) {
        my ( $dow2, $dow2n, $day2, $month2, $year2 ) = &days_from_now( $day_time, $count );
        print OUT "<option value='/" . $parms{db} . "/${day2}_$hour.html'";

        if ( $day2 == $day ) {
            print OUT " Selected ";
        }
        print OUT ">$dow2, $month2/$day2\n";
    }
    print OUT "</select>\n";
    print OUT "<SELECT NAME=tvtime onchange=window.open(this.options[this.selectedIndex].value,'output')>\n";

    for my $hour2 (@hours) {
        my $hour2_ampm;

        if ( $hour2 == 12 ) {
            $hour2_ampm = "12 pm";
        }
        elsif ( $hour2 > 12 ) {
            $hour2_ampm = $hour2 - 12 . " pm";
        }
        elsif ( $hour2 == 0 ) {
            $hour2_ampm = "12 am";
        }
        else {
            $hour2_ampm = $hour2 + 0 . " am";
        }
        print OUT "<option value='/" . $parms{db} . "/${day}_${hour2}.html'";
        if ( $hour2 == $hour ) {
            print OUT " Selected ";
        }

        print OUT ">$hour2_ampm\n";
    }
    print OUT "</select>\n</td>\n";
    print OUT "</tr>\n</form></table></center>\n";
}

#======================================================================
# SUB: delete_old_data
# Delete data that doesn't fall into the following range:
#   $parms{purge} days ago through 7 days from now
#======================================================================
sub delete_old_data {
    my @dates;
    for ( -14 .. $parms{purge} ) {
        my ( $dow, $down, $day, $month ) = &days_from_now( time, -$_ );
        push @dates, "$month/$day";
    }
    print "Deleting old data more than $parms{purge} days ago ...\n";
    print "Keeping these dates ONLY: @dates\n";

    my ( $key, $value );
    while ( ( $key, $value ) = each %DBM ) {
        my ( $channel, $date, $time ) = split( $;, $key );

        # don't delete it if the date matches
        next if ( grep ( /^$date$/, @dates ) > 0 );
        delete $DBM{$key};
    }

    print "Compressing non-purged data\n";

    my $dbm_file_temp = $dbm_file . '.temp';

    unlink $dbm_file_temp if -e $dbm_file_temp;

    my %DBM_TEMP;
    tie( %DBM_TEMP, 'DB_File', $dbm_file_temp, O_RDWR | O_CREAT, 0666 )
      or die "Error, can not open dbm file $dbm_file_temp: $!";

    # copy hash info over to new DBM file
    %DBM_TEMP = %DBM;

    # untie these two hashes
    untie %DBM;
    untie %DBM_TEMP;

    # delete old DBM file
    rename( $dbm_file, $dbm_file . '.to.be.deleted' )
      or die "can't rename to .to.be.deleted: $!";
    rename $dbm_file_temp, $dbm_file
      or die "can't rename from temp to real: $!";
    unlink $dbm_file . '.to.be.deleted';

    # clear hash
    undef %DBM;

    # retie hash
    tie( %DBM, 'DB_File', $dbm_file, O_RDWR | O_CREAT, 0666 )
      or die "Error, can not open dbm file $dbm_file the second time: $!";
    print "Finished deleting old data\n";
}

sub delete_old_data_html {

    #my ($down, $down, $day, $month) = &days_from_now(time, -28);
    my ( $dow, $down, $day, $month ) =
      &days_from_now( time, $parms{purge} * -1 );
    my $pgm_date = "$month/$day";
    print "Deleting old data from $parms{purge} days ago: $pgm_date ...\n";

    for my $hour ( 00 .. 27 ) {
        $hour = '0' . $hour if $hour < 10;
        my $outfile = "$parms{outdir}/${day}_${hour}.html";
        unlink $outfile if -f $outfile;
    }
}

#======================================================================
# fetchLoop
#======================================================================
sub fetchLoop {

    #-------------------------------------------------------
    # Blow away the old data
    #-------------------------------------------------------
    &delete_old_data      unless $parms{keep_old};
    &delete_old_data_html unless $parms{keep_old};
    my ($pgm_date);
    print "Reading in XMLTV file (takes a bit)...\n" if $parms{debug};
    my ( $encoding, $credits, $ch, $progs ) =
      @{ XMLTV::parsefiles( $parms{infile} ) };

    #
    # Read all the channel-associated information into hash %DBM2.
    #
    my $langs = ['en'];
    foreach ( values %$ch ) {
        my $channel_affiliate = '';    # assume it's not an affiliate station
        my $channel_image     = '';    # assume there's no image for the channel
        my $channel_image_path;
        my $channel_ID = $_->{id};     # XMLTV Channel ID
                                       # Pick the best name for the channel
        my ( $channel, $lang ) =
          @{ XMLTV::best_name( $langs, $_->{'display-name'} ) };
        my ( $channel_number, $channel_name ) = $channel =~ /^(.*) (.*)/;

        # rbmod check if channel name has a number at the end...
        #       append the tailing number to $channel_number as a decimal
        my $subchannel = '';
        $subchannel = $channel_name =~ /^.*(\d)$/;

        #	        print "fetchloop: subchnl=$subchannel, chnl_name=$channel_name, $1\n" if $parms(debug);
        $channel_number = $channel_number . '.' . $1 if ($subchannel);

        # rbmod_end
        # Check to see if the station is a network affiliate.
        foreach my $key ( @{ $_->{'display-name'} } ) {
            my $key2 = "@$key";
            if ( $key2 =~ /Affiliate/ ) {
                ($channel_affiliate) = $key2 =~ /(^.*) Affiliate/;
            }
            else { $channel_affiliate = ''; }
        }

        # Check to see if there's an associated image for the channel
        if ($channel_affiliate) {

            # for some reason some of the channel icons are gifs, others jpgs.
            # Check for both
            $channel_image_path = $parms{outdir} . '/logos/' . lc($channel_affiliate) . '.gif';
            if ( ( -e $channel_image_path ) ) {
                $channel_image = qq|<img src="/tv/logos/$channel_affiliate.gif"><br>|;
            }
            else {
                $channel_image_path = $parms{outdir} . '/logos/' . lc($channel_affiliate) . '.jpg';
                if ( ( -e $channel_image_path ) ) {
                    $channel_image = qq|<img src="/tv/logos/$channel_affiliate.jpg"><br>|;
                }
                if ( !($channel_image) ) {
                    $channel_image = "$channel_affiliate<br>";
                }
            }
        }

        # and if it's not an affiliate it could still have an icon.
        else {
            $channel_image_path = $parms{outdir} . '/logos/' . lc($channel_name) . '.jpg';
            if ( ( -e $channel_image_path ) ) {
                $channel_image = qq|<img src="/tv/logos/$channel_name.jpg"><br>|;
            }
        }

        $DBM2{$channel_number} = $channel_name;

        my $db_data = join( $;, $channel_number, $channel_name, $channel_affiliate, $channel_image, $channel_ID );
        $DBM_channel{$channel_number} = $db_data;

        # DBM_index cross references between channels and programs
        $DBM_index{$channel_ID} = join( $;, $channel_number, $channel_ID );
    }

    #
    # Read all the program-associated information into hash %DBM.
    # and %DBM_html.
    #
    foreach (@$progs) {
        my $lang       = '';
        my $channel_ID = $_->{channel};
        my ( $channel_number, $channel_ID ) =
          split( $;, $DBM_index{$channel_ID} );

        my ($time_end_XML) = $_->{stop};
        my ( $pgm_date_end, $time_end ) = &time_from_XML( $_->{stop} );
        my $epoch_end = &convert_XML_to_epoch($time_end_XML);

        my ($time_start_XML) = $_->{start};
        my ( $pgm_date, $time_start ) = &time_from_XML( $_->{start} );
        my $epoch_start = &convert_XML_to_epoch($time_start_XML);

        my $time_start_adj = &time_adj($time_start);
        my $time_end_adj   = &time_adj($time_end);

        my $pgm_air = substr $_->{date}, 0, 4;

        my $pgm_name = '';
        if ( defined $_->{title} ) {
            foreach ( @{ $_->{title} } ) { ( $pgm_name, $lang ) = @$_; }
        }
        my $pgm_title = '';
        if ( defined $_->{'sub-title'} ) {
            foreach ( @{ $_->{'sub-title'} } ) { ( $pgm_title, $lang ) = @$_; }
            $pgm_title = $pgm_title;
        }
        $pgm_name =~ s/  / /g;    # Drop extra spaces
        $pgm_name =~ s/\s+$//;    # remove trailing spaces

        my $pgm_desc = '';
        if ( defined $_->{desc} ) {
            foreach ( @{ $_->{desc} } ) { ( $pgm_desc, $lang ) = @$_; }
        }
        my $pgm_rating = '';
        my $pgm_chip   = '';
        my $pgm_other  = '';
        if ( defined $_->{rating} ) {
            foreach ( @{ $_->{rating} } ) {
                ( $pgm_rating, $pgm_chip, $pgm_other ) = @$_;
            }
        }

        my @pgm_category = ();
        my $lang         = '';
        if ( defined $_->{'category'} ) {
            foreach ( @{ $_->{'category'} } ) {
                my ( $category, $lang ) = @$_;
                push( @pgm_category, $category );
            }
        }

        my $pgm_name_full = "$pgm_name: $pgm_title" if defined $pgm_title;
        $pgm_name_full =~ s/  / /g;    # Drop extra spaces
        $pgm_name_full =~ s/\s+$//;    # remove trailing spaces

        # %DBM_html is an extended data set from %DBM, so we can muck with it and
        # not screw with the actual database. Also would be much bigger.
        my $html_key = join( $;, $channel_number, $pgm_date, $time_start_adj );
        my $html_data = join( $;,
            $time_end,   $pgm_name, $pgm_title,    $pgm_air,     $time_start, $time_start_adj, $time_end_adj,
            $pgm_rating, $pgm_desc, $pgm_date_end, $epoch_start, $epoch_end,  @pgm_category );
        $DBM_html{$html_key} = $html_data;
        my $db_key  = join( $;, $channel_number, $pgm_date,      $time_start );
        my $db_data = join( $;, $time_end,       $pgm_name_full, 0 );
        $DBM{$db_key} = $db_data;

        #print "DBM: db key=$db_key\ndata=$db_data.\n" if $parms{debug};
    }
}

# ========================================================
# sub ampm_to_hour24
# Converts time from clock time to 24 hour time
# ========================================================
sub ampm_to_hour24 {
    my ( $hour, $min, $ampm ) = @_[0] =~ /(\d+):?(\d*) *(\S*)/;
    $hour += 12 if uc($ampm) eq 'PM' and $hour < 12;
    $hour -= 12 if uc($ampm) eq 'AM' and $hour == 12;
    $hour = sprintf( "%02d", $hour );
    $min = "00" unless $min;
    $hour .= ":$min";
    return $hour;
}

# ========================================================
# sub time_from_XML
# Convert the XML time to clock time/date
# ========================================================
sub time_from_XML {
    my ($time) = @_;
    $time =~ /(\d\d\d\d)(\d\d)(\d\d)(\d\d)(\d\d)\d\d -.*/;
    my @time_strip = ( $1, $2, $3, $4, $5 );
    my @time_split = ();
    foreach (@time_strip) {
        push( @time_split, sprintf( "%02d", $_ ) );
    }
    my ( $yy, $mm, $dd, $hr, $mn ) = @time_split;
    return ("$mm/$dd"), ("$hr:$mn");
}

# ========================================================
# sub convert_XML_to_epoch
# Convert the XML time to epoch time
#     Note: "norms" the time
# ========================================================
sub convert_XML_to_epoch {
    my ( $time_xml, $time ) = @_;
    $time_xml =~ /(\d\d\d\d)(\d\d)(\d\d)(\d\d)(\d\d)(\d\d) -.*/;
    my ( $year, $month, $mday, $hour, $min, $sec ) = ( $1, $2, $3, $4, $5, $6 );
    $month = $month - 1;    # to fix for XML vs timelocal

    # Norm the time
    if    ( $min >= 0 & $min <= 15 ) { $min = 0; }
    elsif ( $min > 15 & $min <= 45 ) { $min = 30; }
    elsif ( $min > 45 & $min <= 59 ) { $min = 0; }

    $time = timelocal( $sec, $min, $hour, $mday, $month, $year );
    return $time;
}

# ========================================================
# sub convert_epoch_to_time
# Switches epoch time to  date, 24 hour time
# ========================================================
sub convert_epoch_to_time {
    my ($epoch) = @_;
    my ( $Second, $Minute, $Hour, $DayofMonth, $WrongMonth, $WrongYear, $WeekDay, $DayofYear, $IsDST ) = localtime($epoch);
    my $Month = $WrongMonth + 1;
    my $Year  = $WrongYear + 1900;
    return ( sprintf( '%02d/%02d', $Month, $DayofMonth ), sprintf( '%02d:%02d', $Hour, $Minute ) );
}

# ========================================================
# sub convert_time_to_epoch
# Switches normal time to epoch time
# ========================================================
sub convert_time_to_epoch {
    my ( $sec, $min, $hour, $mday, $month, $year ) = @_;
    $month = $month - 1;
    my $time = timelocal( $sec, $min, $hour, $mday, $month, $year );
    return $time;
}

#======================================================================
# sub time_adj
# Fix the time so that shows have a consistent beginning or end
# ending exactly on the hour or half hour
#
# Dumb stations that decided to have shows start at, say, 11:35
# makes finding them in the index hard
#
# could have also solved this by reading through the index one minute
# at a time and in hindsight that might have been easier
#======================================================================
sub time_adj {
    my ($time) = @_;
    my ( $hour, $min ) = $time =~ /(.*):(.*)/;
    my $time_adj = '';
    if ( !( $min eq '30' | $min eq '00' ) ) {
        if    ( $min >= 0 & $min <= 15 ) { $time_adj = $hour . ':00'; }
        elsif ( $min > 15 & $min <= 45 ) { $time_adj = $hour . ':30'; }
        elsif ( $min > 45 & $min <= 59 ) { $time_adj = $hour . ':00'; }
    }
    else { $time_adj = "$hour:$min"; }
    return $time_adj;
}

#======================================================================
# sub pgm_color
# Selects the display color for programs based on their Category
# Picks the first category for the show
# Defaults to grey
#=====================================================================
sub pgm_color {

    # Determine the background color for the TV shows in the grid.
    my ($pgm_category) = @_;
    my $pgm_color = '#cccccc';    # Default color
    if    ( $pgm_category =~ /Action/ )     { $pgm_color = '#99ccff'; }
    elsif ( $pgm_category =~ /Adventure/ )  { $pgm_color = '#99ccff'; }
    elsif ( $pgm_category =~ /Bus/ )        { $pgm_color = '#9999cc'; }
    elsif ( $pgm_category =~ /Children/ )   { $pgm_color = '#ccffcc'; }
    elsif ( $pgm_category =~ /Comedy/ )     { $pgm_color = '#99ccff'; }
    elsif ( $pgm_category =~ /Crime/ )      { $pgm_color = '#cccccc'; }
    elsif ( $pgm_category =~ /Drama/ )      { $pgm_color = '#cccccc'; }
    elsif ( $pgm_category =~ /Fantasy/ )    { $pgm_color = '#cccccc'; }
    elsif ( $pgm_category =~ /Game show/ )  { $pgm_color = '#cccccc'; }
    elsif ( $pgm_category =~ /Horror/ )     { $pgm_color = '#ff0000'; }
    elsif ( $pgm_category =~ /Music/ )      { $pgm_color = '#cccccc'; }
    elsif ( $pgm_category =~ /Mystery/ )    { $pgm_color = '#cccccc'; }
    elsif ( $pgm_category =~ /News/ )       { $pgm_color = '#9999cc'; }
    elsif ( $pgm_category =~ /Paid/ )       { $pgm_color = '#ffffcc'; }
    elsif ( $pgm_category =~ /Paranormal/ ) { $pgm_color = '#ffffcc'; }
    elsif ( $pgm_category =~ /Reality/ )    { $pgm_color = '#cccccc'; }
    elsif ( $pgm_category =~ /Science/ )    { $pgm_color = '#0033ff'; }
    elsif ( $pgm_category =~ /Shopping/ )   { $pgm_color = '#ffffcc'; }
    elsif ( $pgm_category =~ /Sitcom/ )     { $pgm_color = '#ffff66'; }
    elsif ( $pgm_category =~ /Special/ )    { $pgm_color = '#ccff33'; }
    elsif ( $pgm_category =~ /Sports/ )     { $pgm_color = '#ffcc00'; }
    elsif ( $pgm_category =~ /Suspense/ )   { $pgm_color = '#cccccc'; }
    elsif ( $pgm_category =~ /Travel/ )     { $pgm_color = '#9999cc'; }
    elsif ( $pgm_category =~ /Weather/ )    { $pgm_color = '#9999cc'; }
    else                                    { $pgm_color = '#cccccc'; }
    return $pgm_color;
}

#======================================================================
# sub display_program
# Builds the HTML for an individual program display
#======================================================================
sub display_program {

    # Make the Display output for the tv_grid html page
    my ( $pgm_name, $pgm_title, $pgm_desc, $pgm_air, $pgm_rating, $channel_number, $time_start, $time_start_adj, $time_end, $pgm_date, $colspan, @pgm_category )
      = @_;
    my ( $program, $pgm_category, $pgm_color, $time_wrong );

    # Format the program category, color-code as appropriate
    # Pick the color from the first listed category
    foreach my $key (@pgm_category) {

        # Filter out "series" - who really cares
        if ( !( $key =~ /Series/ ) ) {
            if ($pgm_category) { $pgm_category .= "/" . $key; }
            else {
                $pgm_category = $key;
                $pgm_color    = &pgm_color($pgm_category);
            }
        }
    }

    $program = "<B>$pgm_name</B>";
    $program .= ": <i>$pgm_title</i>" if ($pgm_title);
    $program .= ".";
    $program .= " (" if ( defined $pgm_category || defined $pgm_air );
    $program .= "$pgm_air, "    if ($pgm_air);
    $program .= "$pgm_category" if defined $pgm_category;
    $program .= "). "           if ( defined $pgm_category || defined $pgm_air );

    $program .= " $pgm_desc"   if defined $pgm_desc;
    $program .= " $pgm_rating" if defined $pgm_rating;

    if ( $parms{label} eq "VCR" ) {
        $program =
            q|<a href='/SET:last_spoken?$tv_grid?channel_|
          . $channel_number
          . '_from_'
          . $time_start . '_to_'
          . $time_end . '_on_'
          . $pgm_date . '_for_'
          . $pgm_name
          . q|'>VCR</a> for |
          . $program;
    }

    # When the start time isn't exactly right, display it
    if ( $time_start ne $time_start_adj ) {
        $time_wrong = qq|(<i>$time_start</i>) |;
    }
    $program = qq|<td bgcolor="$pgm_color" colspan="$colspan" width="$colspan| . qq|0%" valign="top">$time_wrong$program</td>|;

    return $program;
}

#======================================================================
# M A I N
#======================================================================
setup();
if ( -1 == fetchLoop() ) {
    print "Grid Update failed\n";
    exit -1;
}

# If a HTML directory has been defined, parse through the $DBM arrays and
# generate the ia5 web pages
if ( $parms{outdir} ) { processRawFile(); }

print "Grid Update for $parms{db} complete\n";

untie %DBM;
untie %DBM2;
