package Event_Logger;

use strict;
 
@Event_Logger::ISA = ('Generic_Item');

sub new {
   my ($class,$method) = @_;
   my $self={};
   bless $self,$class;
   @{$$self{_active_IDs}} = ();
   $$self{event} = ();
   $$self{_current_ID} = 0;
   $$self{icalname} = "MisterHouse autogenerated";
   $$self{enabled} = 1;
# object data
#	array of active "ID's" (events in memory that haven't ended)
#	ID of the most current event
#	filename
#	method and ical name
#	hash {event}{$ID}
#		=> {summary}
#		=> {start}
#		=> {end}
   return $self;
}


sub event_start() {
# create a new event and make it active

  my ($self, $summary) = @_;

  if ($$self{enabled}) {

    $$self{_current_ID}++;
    my $id = $$self{_current_ID};
    my ($now_time) = $main::Time_Date;
    push @{$$self{_active_IDs}}, $id;
#print "aid2=@{$$self{_active_IDs}}, id=$id\n";
    $summary = "none" if ($summary eq "");
    $$self{event}{$id}{summary} = $summary;
    $$self{event}{$id}{start} = $now_time;

#  print "start, [$$self{event}{$id}{summary}][$$self{event}{$id}{start}]\n";
    return $id;

  } else {
    return -1; #event_logging is disabled
  }
}
 
sub event_end {
# close an active event and flush it to a file

  my ($self, $id) = @_;
  my $found = 0;

  if ($$self{enabled}) {
     if ($id) {
        my $count;
        for my $item (@{$$self{_active_IDs}}) {
#print "it=$item, id=$id\n";
           $count++;
           if ($item == $id) {
           splice (@{$$self{_active_IDs}}, $count,1 );
           $found = 1;
           }
         }
      } else {
	   $id = pop @{$$self{_active_IDs}};
           $found = 1 if $id;
     }

     if ($found) {
        my ($now_time) = $main::Time_Date;
        $$self{event}{$id}{end} = $now_time;
#  print "end, [id=$id][$$self{event}{$id}{summary}][$$self{event}{$id}{start}][$$self{event}{$id}{end}]\n";  
        $self->_write_event($id);
     } else {
        print "cannot find id $id!\n";
     }
     return $found; 
   } else {
     return -1; #disabled
   }
}

sub active_ids {
# returns array of active events (ie events that have not ended)
  my ($self) = @_;

  return \@{$$self{_active_IDs}}; #doesn't return array?
}

sub current_id {
#returns the last used id number
  my ($self) = @_;

  return $$self{_current_ID};
}

sub get_filename {

  my ($self) = @_;
  my $filepath = $main::config_parms{data_dir};
  $filepath = $main::config_parms{ical_data_dir} if $main::config_parms{ical_data_dir};
  my $file = $$self{object_name};
  $file =~ s/^\$//;
  my $fname =  $filepath . "/eventlog_" . $file . ".data";
  return $fname;
}

sub in_event {

   my ($self,$epoch_seconds) = @_;
   my $fname = $self->get_filename;

   if (open ELFILE, "$fname") {
     my @data = <ELFILE>;
     close ELFILE;
     foreach my $line (@data) {

       my ($start,$end,$entry) = split /\t/,$line;
#print "db in_event start= " . &main::my_str2time($start) . " sec= $epoch_seconds end= ". &main::my_str2time($end) . "\n";
       return 1 if ((&main::my_str2time($start) <= $epoch_seconds) and 
		    (&main::my_str2time($end) >= $epoch_seconds));
     }
   } else {
     print "problem opening data file $fname\n";
   }
  # check if in memory...
    
    return 0;
}
 
sub first_event {

   my ($self) = @_;
   my ($self) = @_;
   my $fname = $self->get_filename;
print "reading firest_event $fname...\n";
  if (open ICFILE, "$fname") {
     my @data = <ICFILE>;
     close ICFILE;
     my $last = shift (@data);
     my ($start,$end,$entry) = split /\t/,$last;
     return &main::my_str2time($start);

  } else {

     my $current_id = $self->current_id;
     if (defined $$self{event}{$current_id}{start}) {

	return &main::my_str2time($$self{event}{$current_id}{start})
     }
   }
   return 0;
}
 
sub last_event {

   my ($self) = @_;
   my $fname = $self->get_filename;
print "reading last_event $fname...\n";
  if (open ICFILE, "$fname") {
     my @data = <ICFILE>;
     close ICFILE;
     my $last = pop (@data);
     my ($start,$end,$entry) = split /\t/,$last;
     return &main::my_str2time($end);

  } else {
     return 0;
  }
}

sub enable_logging {

   my ($self) = @_;
   $$self{enabled} = 1;
}

sub disable_logging {

   my ($self) = @_;
   $$self{enabled} = 0;
}

#sub log_object {
#
# ideally for any object to enable logging

# $target = new Generic_item;
# $target_logger = new Event_Logger;
#
# $target_logger->log_object($target, start => 'on', end => 'off');
#
#  my ($self, $target, %hash) = @_;
# this would be useful a tie method that would specify start, end and summary conditions
# ie $item->tie_interface($object, "start => open, end => closed, summary => \"garage door event\");
# }

sub _write_event {
# writes closed events to log

  my ($self, $id) = @_;
  my $fname = $self->get_filename;
print "writing to $fname...\n";
  if (open ICFILE, ">>$fname") {
     #format: start<tab>end<tab>summary
     print  "[id=$id][$$self{event}{$id}{start}][$$self{event}{$id}{end}][$$self{event}{$id}{summary}]\n";
     print ICFILE "$$self{event}{$id}{start}\t$$self{event}{$id}{end}\t$$self{event}{$id}{summary}\n";
     close (ICFILE);
  } else {
     print "error opening $fname for write!\n";
     print "abandoning cal entry $id\n";
  }

} 

#-----------------
# Event_Logger display methods

sub generate_ical_file {
# creates an ical formatted .ics file on the webserver for import into external clients, phpicalendar, etc...

  my ($self, $file, $start, $end) = @_;
  my $filepath = $main::Pgm_Root . "/web";
  #my $filepath ="/usr/local/mh/web";
  $filepath = $main::config_parms{ical_publish_dir} if $main::config_parms{ical_publish_dir};
  $file = $$self{object_name} if (!$file);
  $file =~ s/^\$//;
  my $fname = $filepath . "/" . $file . ".ics";
  my $retcode;

  if (open (ICDATA, ">$fname")) {
    print ICDATA $self->generate_ical_data($start,$end);
    close (ICDATA);
    $retcode = 1;
  } else {
    print "cannot open $fname for writing!";
    $retcode = 0;
  }
 return $retcode
}

sub generate_ical_data {
# returnes a generated ical formatted string of events between start and end
# if start & end ommitted, then entire range is returned (TODO)

use Date::ICal; #included in MH
use Data::ICal; #included in MH
use Data::ICal::Entry::Event; #new Dep

  my ($self, $start, $end) = @_;
  my $filepath = $main::config_parms{data_dir};
  $filepath = $main::config_parms{ical_data_dir} if $main::config_parms{ical_data_dir};
  my $file = $$self{object_name};
  $file =~ s/^\$//;
  my $fname =  $filepath . "/eventlog_" . $file . ".data";
  my $calendar = new Data::ICal;
  $calendar->add_properties(
           method      => $$self{method},
	  # name        => $$self{name},
  );
 
  my $event = Data::ICal::Entry::Event->new();

  if ( -e $fname ) {
    if (open ICFILE, "$fname") {
     foreach my $line (<ICFILE>) {
        my ($start,$end,$summary) = split /\t/,$line;
	#start,end not implemented yet
        my ($start1,$end1);
        $start1 = &main::my_str2time($start);
        $end1 = &main::my_str2time($end);
        $event->add_properties(
 	   summary     => $summary,
 	   #description => "FreeFormText.\\nMore FreeFormText.\\n\\n",
 	   #dtstart     => Date::ICal->new( epoch => time )->ical,
 	   dtstart     => Date::ICal->new( epoch => $start1 )->ical,
 	   dtend       => Date::ICal->new( epoch => $end1 )->ical,
 	   dtstamp     => Date::ICal->new( epoch => time )->ical,
 	   #class       => "PUBLIC",
 	   #organizer   => "MAILTO:foo\@bar",
 	   #location    => "Phone call",
 	   #priority    => 5,
 	   #transp      => "OPAQUE",
 	   #sequence    => 0,
 	   #uid         => "123",
	   );
        $calendar->add_entry($event);
      }
     close (ICFILE);
    } else {
     print "error opening $fname for read\n";
    }
   }
  

   foreach my $id (@{$$self{_active_IDs}}) {
        my ($start1,$end1);
        my $start = $$self{event}{$id}{start};
        $start1 = &main::my_str2time($start);
        $event->add_properties(
 	   summary     => $$self{event}{$id}{summary},
 	   #description => "FreeFormText.\\nMore FreeFormText.\\n\\n",
 	   #dtstart     => Date::ICal->new( epoch => time )->ical,
 	   dtstart     => Date::ICal->new( epoch => $start1 )->ical,
 	   dtend       => Date::ICal->new( epoch => time )->ical,
 	   dtstamp     => Date::ICal->new( epoch => time )->ical,
 	   #class       => "PUBLIC",
 	   #organizer   => "MAILTO:foo\@bar",
 	   #location    => "Phone call",
 	   #priority    => 5,
 	   #transp      => "OPAQUE",
 	   #sequence    => 0,
 	   #uid         => "123",
	   );
       $calendar->add_entry($event);
   }
 
  return $calendar->as_string;

}

sub generate_graph_file {
# creates an ical formatted .ics file on the webserver for import into external clients, phpicalendar, etc...

  my ($self, $file, $start, $end, $step) = @_;
  my $filepath = $main::Pgm_Root . "/web";
  #my $filepath ="/usr/local/mh/web";
  $filepath = $main::config_parms{ical_publish_dir} if $main::config_parms{ical_publish_dir};
  $file = $$self{object_name} if (!$file);
  $file =~ s/^\$//;
  my $fname = $filepath . "/" . $file . ".gif";
  my $retcode;

  ##if (open (ELIMG, ">$fname")) {
  ##   binmode ELIMG;
  ##   print ELIMG $self->generate_graph_data($start,$end,$step);
  ##   close ELIMG;
  ##   $retcode = 1;
  ##} else {
  ##  print "cannot open $fname for writing!";
  ##  $retcode = 0;
  ##}
$self->generate_graph_data($start,$end,$step);
 return $retcode
}


sub generate_graph_data {
# returnes a generated ical formatted string of events between start and end
# if start & end ommitted, then entire range is returned (TODO)

  use GD::Graph; #new dep
  use GD::Graph::lines; #new dep
  my ($self, $start, $end, $step) = @_;
 
  my $height = 400;
  my $width = 300;
 
  $start = $self->first_event if !$start;
  $end   = $self->last_event if !$end;
  $step  = 300 if !$step; #default to 5 minutes
  my @graph_data_time;
  my @graph_data_status;
  my @graph_data;

print "db:start=$start,end=$end,step=$step\n"; 

  my $count = 0;
  for (my $index = $start; $index <= $end; $index=$index+$step) {
# $data{$index} = $object->in_event($index);
#    @graph_data[0]->[$count] = &main::time_date_stamp(14,$index);
#    @graph_data[1]->[$count] = $self->in_event($index);
    @graph_data_time[$count] = &main::time_date_stamp(14,$index);
#    my $temp = $self->in_event($index); #get graphing working first...
    my $temp_rnd = rand() * 100;
    my $temp = 0;
    $temp = 1 if ($temp_rnd > 80);
    @graph_data_status[$count] = $temp;
print "db:count=$count, index=$index end=$end" . &main::time_date_stamp(14,$index) . " $temp\n";
    $count++;
  }

  @graph_data = (\@graph_data_time,\@graph_data_status); 
  print @graph_data_time,@graph_data_status;

  my $graph = GD::Graph::lines->new($height,$width);
  $graph->set (
    x_label => 'Time',
    y_label => 'State',
    title   => 'Graph of self->get_name');
 
  my $fname ="/usr/local/mh/web/test.gif";

  if (open (ELIMG, ">$fname")) {
     binmode ELIMG;
     print ELIMG $graph->plot(\@graph_data);
     close ELIMG;
  }
 
}
 
